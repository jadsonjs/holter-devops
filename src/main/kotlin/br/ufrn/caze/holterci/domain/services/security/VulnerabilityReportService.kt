package br.ufrn.caze.holterci.domain.services.security

import br.ufrn.caze.holterci.domain.models.metric.Project
import br.ufrn.caze.holterci.domain.models.security.Vulnerability

import br.ufrn.caze.holterci.domain.models.security.ProjectVulnerabilities
import br.ufrn.caze.holterci.domain.utils.CloneGitLabUtil
import br.ufrn.caze.holterci.domain.utils.EmailUtil
import br.ufrn.caze.holterci.domain.utils.PdfUtil
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service

/**
 * Service responsible for generating and sending vulnerability reports for a list of projects.
 */
@Service
class VulnerabilityReportService(
    private val cloneGitLabUtil: CloneGitLabUtil,
    private val pdfUtil: PdfUtil,
    private val mailUtil: EmailUtil,
    private val grypeService: GrypeService,
    private val trivyService: TrivyService,
    @Value("\${projects.path}") private val projectsPath: String,
    ) {


    /**
     * Generates a vulnerability report for the given list of projects and sends it via email to the specified recipients.
     *
     * @param projects the list of projects to include in the report.
     * @param recipients a list of email addresses to send the report to.
     * @param appUrl the URL of the application to include in the email.
     */
    fun generateAndSendReport(projects: List<Project>, recipients: List<String>, appUrl: String) {
        val allVulnerabilities = collectVulnerabilities(projects)
        val pdfReportFile = generateReportInPDF(allVulnerabilities)
        mailUtil.sendVulnerabilityAlertMail(projects, pdfReportFile, recipients, allVulnerabilities.isEmpty(), appUrl)
    }



    /**
     * Gets a vulnerability report for the given projects.
     *
     * @param projects the list of projects to include in the report.
     * @return a PDF file as a ByteArray containing the vulnerability report for the given projects.
     */
    fun generateReport(projects: List<Project>): ByteArray {
        val allVulnerabilities = collectVulnerabilities(projects)
        return generateReportInPDF(allVulnerabilities)
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    // where the collection takes place
    private fun collectVulnerabilities(projects: List<Project>): List<ProjectVulnerabilities> {
        cloneAllProjects(projects)

        val grypeResults = grypeService.scanProjectsForVulnerabilities(projects)
        val trivyResults = trivyService.scanProjectsForVulnerabilities(projects)

        return mergeVulnerabilities(grypeResults, trivyResults)
    }


    /**
     * Clones or updates all unique projects in the local file system.
     *
     * TODO: if a project do not use gitlab ?
     *
     * @param projects the list of projects to clone.
     */
    private fun cloneAllProjects(projects: List<Project>) {
        for (project in projects.distinctBy { it.id }) {
            val localRepo = "$projectsPath/${project.name}"
            cloneGitLabUtil.cloneOrUpdateRepository(project, localRepo)
        }
    }


    /**
     * Generates a PDF report from the list of projects and their associated vulnerabilities.
     *
     * @param projectsWithVulnerabilities the list of projects and their vulnerabilities to include in the report.
     * @return a PDF file as a ByteArray containing the vulnerability report.
     */
    private fun generateReportInPDF(projectsWithVulnerabilities: List<ProjectVulnerabilities>): ByteArray {
        return pdfUtil.generateVulnerabilityPdf(projectsWithVulnerabilities)
    }

    /**
     * Merges the vulnerability results from Grype and Trivy for each project.
     * Assumes the same set of projects was scanned by the tools and matches them by project ID.
     * Duplicated vulnerabilities (by ID) are removed and sorted by severity in descending order.
     *
     * @param grype list of vulnerability results from Grype.
     * @param trivy list of vulnerability results from Trivy.
     * @return a merged list of vulnerabilities per project.
     */
    fun mergeVulnerabilities(
        grype: List<ProjectVulnerabilities>,
        trivy: List<ProjectVulnerabilities>
    ): List<ProjectVulnerabilities> {
        val trivyMap = trivy.associateBy { it.project.id }

        return grype.map { g ->
            val t = trivyMap[g.project.id]

            val combined = (g.vulnerabilities + (t?.vulnerabilities ?: emptyList()))
                .groupBy { it.id }
                .map { (_, dups) ->
                    // Merge duplicates, prioritizing fixedInVersion, description, etc.
                    dups.reduce { a, b ->
                        Vulnerability(
                            id = a.id,
                            packageName = a.packageName.ifBlank { b.packageName },
                            type = a.type ?: b.type,
                            severity = maxOf(a.severity, b.severity, compareBy { it.order }),
                            description = when {
                                a.description != null && b.description != null ->
                                    if (a.description.length >= b.description.length) a.description else b.description
                                else -> a.description ?: b.description
                            },
                            link = a.link ?: b.link,
                            currentVersion = a.currentVersion.ifBlank { b.currentVersion },
                            fixedInVersion = a.fixedInVersion ?: b.fixedInVersion
                        )
                    }
                }
                .sortedByDescending { it.severity.order } // order by severity

            g.copy(vulnerabilities = combined)
        }
    }


}
